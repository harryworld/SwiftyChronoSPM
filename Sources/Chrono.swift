//
//  Chrono.swift
//  SwiftyChrono
//
//  Created by Jerry Chen on 1/18/17.
//  Copyright Â© 2017 Potix. All rights reserved.
//

import Foundation

private final class LockedValue<Value>: @unchecked Sendable {
    // Safety: all access to `value` is protected by `lock`.
    // TODO: Replace with a Sendable lock wrapper (e.g. ManagedCriticalState) to drop @unchecked Sendable.
    private let lock = NSLock()
    private var value: Value

    init(_ value: Value) {
        self.value = value
    }

    func get() -> Value {
        lock.lock()
        defer { lock.unlock() }
        return value
    }

    func set(_ newValue: Value) {
        lock.lock()
        value = newValue
        lock.unlock()
    }
}

public enum OptionType: String { case
    morning = "morning",
    afternoon = "afternoon",
    evening = "evening",
    noon = "noon",
    yearRemoval = "yearRemoval",
    forwardDate = "forwardDate",
    littleEndian = "littleEndian"
}

public struct Chrono {
    /// iOS's Calender.Component to date that has 6 minutes less if the date is before 1900 (compared to JavaScript or Java)
    /// If your use case will include both be ealier than 1900 and its minutes, seconds, nanoseconds, (milliseconds)
    /// you should turn on this fix.
    private static let sixMinutesFixBefore1900Value = LockedValue(false)
    public static var sixMinutesFixBefore1900: Bool {
        get { sixMinutesFixBefore1900Value.get() }
        set { sixMinutesFixBefore1900Value.set(newValue) }
    }
    
    /// In some cases, a keyword for a langugage A means week, for language B could be a non-date related word.
    /// To prevent from getting conflict with other languages, we can simply set the preferred language.
    /// The idead is that if there are at least a reasult generated by the preferred language parser, the parsing will end without
    /// iterating via other languages parser. Otherwise, all parsers will be used in the parsing execution.
    private static let preferredLanguageValue = LockedValue<Language?>(nil)
    public static var preferredLanguage: Language? {
        get { preferredLanguageValue.get() }
        set { preferredLanguageValue.set(newValue) }
    }
    
    /// you can set default imply hour
    private static let defaultImpliedHourValue = LockedValue(12)
    public static var defaultImpliedHour: Int {
        get { defaultImpliedHourValue.get() }
        set { defaultImpliedHourValue.set(newValue) }
    }
    /// you can set default imply minute
    private static let defaultImpliedMinuteValue = LockedValue(0)
    public static var defaultImpliedMinute: Int {
        get { defaultImpliedMinuteValue.get() }
        set { defaultImpliedMinuteValue.set(newValue) }
    }
    /// you can set default imply second
    private static let defaultImpliedSecondValue = LockedValue(0)
    public static var defaultImpliedSecond: Int {
        get { defaultImpliedSecondValue.get() }
        set { defaultImpliedSecondValue.set(newValue) }
    }
    /// you can set default imply millisecond
    private static let defaultImpliedMillisecondValue = LockedValue(0)
    public static var defaultImpliedMillisecond: Int {
        get { defaultImpliedMillisecondValue.get() }
        set { defaultImpliedMillisecondValue.set(newValue) }
    }
    
    let modeOption: ModeOptio
    var parsers: [Parser] { return modeOption.parsers }
    var refiners: [Refiner] { return modeOption.refiners }
    
    public init(modeOption: ModeOptio = casualModeOption()) {
        self.modeOption = modeOption
    }
    
    public func parse(text: String, refDate: Date = Date(), opt: [OptionType: Int] = [:]) -> [ParsedResult] {
        var allResults = [ParsedResult]()
        
        if text.isEmpty {
            return allResults
        }
        
        if let lang = Chrono.preferredLanguage {
            // first phase: preferredLanguage parsers
            for parser in parsers {
                if parser.language == .english || parser.language == lang {
                    allResults += parser.execute(text: text, ref: refDate, opt: opt)
                }
            }
            
            // second phase: other language parsers
            if allResults.isEmpty {
                for parser in parsers {
                    if parser.language != .english && parser.language != lang {
                        allResults += parser.execute(text: text, ref: refDate, opt: opt)
                    }
                }
            }
        } else {
            for parser in parsers {
                allResults += parser.execute(text: text, ref: refDate, opt: opt)
            }
        }
        
        allResults.sort { $0.index < $1.index }
        
        for refiner in refiners {
            allResults = refiner.refine(text: text, results: allResults, opt: opt)
        }
        
        return allResults
    }
    
    public func parseDate(text: String, refDate: Date = Date(), opt: [OptionType: Int] = [:]) -> Date? {
        let results = Chrono.casual.parse(text: text, refDate: refDate, opt: opt)
        return results.first?.start.date
    }
    
    public static var strict: Chrono { Chrono(modeOption: strictModeOption()) }
    public static var casual: Chrono { Chrono(modeOption: casualModeOption()) }
}
